/*
private public protected 차이

파생 클래스는 베이스 클래스의 멤버 함수를 사용할 수 있는데 이 때 맴버함수에서 베이스클레스의 private멤버 변수를 사용하면 오류가 난다.
class base final-> 상속을 방지한다 메서드도 final로 오버라이딩을 방지 할 수 있다.

베이스 클래스의 메서드를 오버라이드할 때는 항상 override키워드를 붙이자-> 함수를 수정하다가 실수(생각해보자)를 하였을때 컴파일 에러가 나게 해준다.

객체 자신은 멤버가 어느 클래스에 속해 있는지 알기 때문에 virtual로 선언됐다면 가장 적합한 메서드를 호출한다.
베이스 클래스 타입의 레퍼런스나 포인터가 실제로 파생 클래스 타입 객체를 가리킨다 해도 베이스 클래스에 정의 되지 않는 파생 클래스의 데이터 멤버나 메서드는 접근할 수 없다.
파생 클래스를 인식해서 적합한 메서드를 호출하는 기능은 포인터나 레퍼런스 객체에만 적용된다.
////
virutal로 선언되지 않은 메서드를 호출하면 정적 바인딩이 되고 virutal로 구현하면 가상테이블이라부르는 특수한 메모리 영역을 활용해 가장 적합한 구현코드를 호출한다 즉 동적 바인딩을 한다.
////
class Base;
class Derived:pulic Base;

Base* ptr = new Derived();
delete ptr;
-> ~Base는 호출 되지만 Derived소멸자는 호출 되지 않아 메모리 해제가 안된다.
소멸자는 꼭 virtual로 해주자

객체 생성 과정
	1. 베이스 클래스라면 디폴트 생성자를 실행한다. 단, 생성자 이니셜라이저가 있다면 디폴트 생성자 대신 생성자 이니셜라이저를 호출한다.
	2. static으로 선언하지 않은 데이터 멤버를 코드에 나타난 순서대로 생성한다.
	3. 클래스 생성자의 본문을 실행한다.
	-> 이 과정이 재귀적으로 실행된다.

만약 디폴트 생성자 없이 베이스 클래스를 정의 했다면
파생 클래스 에서는 반드시 베이스 생성자를 호출하는 방법을 알려줘야한다.
파생::파생() : 베이스(7)//여기서 인자는 데이터 멤버가 될 수 없다 왜인지 생각해보자

객체 소멸 과정
	1. 현재 클래스의 소멸자를 호출한다.
	2. 현재 클래스의 데이터 멤버를 생성할 때와 반대 순서로 삭제한다.
	3. 부모 클래스가 있다면 부모의 소멸자를 호출한다.
만약 소멸자를 virtual로 생성 안한 파생클래스 객체를 가르키는 베이스클래스 객체 포인터를 삭제한다면
문제가 생긴다. 생각해보자 -

순수 가상메서드가 하나라도 정의된 클래스를 추상 클래스라고 부른다
->추상 클래스에 대해서는 인트턴스를 만들 수 없다.

베이스 클래스의 리턴 타입이 다른 클래스에 대한 포인터나 레퍼런스 타입이면 메서드를 오버라이드할 때 리턴 타입을 그 클래스의 파생 클래스에 대한 포인터나 래퍼런스 타입으로 바꿀 수 있다.
->공변 리턴타입ㅁㅁㅁㅁㅁㅁㅁㅁㅁ

static 메서드는 오버라이드 할 수 없다. 그리고 래퍼런스를 사용해 호출한다해도 상속에 관계없이 클래스 이름으로 호출 하는 문장처럼 된다.

베이스 클래스에 다양한 버전으로 오버로드된 메서드가 있을때 파생클래스에서 한버전만 오버라이드 한다면 나머지 버전은 가려지게 된다.
- 파생클래스에서 가려진버전에 접근하려면 배이스 클래스의 레퍼런스나 포인터로 접근하면 도ㅓㅣㄴ다.
- using base::overload를 사용해도 가능 -> 주의해서 사용하자 왜인지는 생각해보고

private 멤버함수 오버로드? 가능하다는데 뭐고이게

디폴트 인수는 컴파일 시간에 결정하기때문에 래퍼런스로 했다면 가르키는 클래스에 상관없이 레퍼런스의 인수를 따라간다.

베이스 클래스에서 public으로 선언한 메서드의 접근 범위는 완벽히 좁힐 수 없다.

파생 클래스에서 복제 생성자를 명시적으로 정의하면 반드시 부모클래스의 복제 생성자를 호출해야 한다. 그렇지 않으면 객체에서 부모 부분에 대해 디폴트 생성자가 사용된다.

typeid 객체의 클래스이름 출력

*/