/*
private public protected 차이

파생 클래스는 베이스 클래스의 멤버 함수를 사용할 수 있는데 이 때 맴버함수에서 베이스클레스의 private멤버 변수를 사용하면 오류가 난다.
class base final-> 상속을 방지한다 메서드도 final로 오버라이딩을 방지 할 수 있다.

베이스 클래스의 메서드를 오버라이드할 때는 항상 override키워드를 붙이자-> 함수를 수정하다가 실수(생각해보자)를 하였을때 컴파일 에러가 나게 해준다.

객체 자신은 멤버가 어느 클래스에 속해 있는지 알기 때문에 virtual로 선언됐다면 가장 적합한 메서드를 호출한다.
베이스 클래스 타입의 레퍼런스나 포인터가 실제로 파생 클래스 타입 객체를 가리킨다 해도 베이스 클래스에 정의 되지 않는 파생 클래스의 데이터 멤버나 메서드는 접근할 수 없다.
파생 클래스를 인식해서 적합한 메서드를 호출하는 기능은 포인터나 레퍼런스 객체에만 적용된다.
////
virutal로 선언되지 않은 메서드를 호출하면 정적 바인딩이 되고 virutal로 구현하면 가상테이블이라부르는 특수한 메모리 영역을 활용해 가장 적합한 구현코드를 호출한다 즉 동적 바인딩을 한다.
////
class Base;
class Derived:pulic Base;

Base* ptr = new Derived();
delete ptr;
-> ~Base는 호출 되지만 Derived소멸자는 호출 되지 않아 메모리 해제가 안된다.
소멸자는 꼭 virtual로 해주자

객체 생성 과정
	1. 베이스 클래스라면 디폴트 생성자를 실행한다. 단, 생성자 이니셜라이저가 있다면 디폴트 생성자 대신 생성자 이니셜라이저를 호출한다.
	2. static으로 선언하지 않은 데이터 멤버를 코드에 나타난 순서대로 생성한다.
	3. 클래스 생성자의 본문을 실행한다.
	-> 이 과정이 재귀적으로 실행된다.

만약 디폴트 생성자 없이 베이스 클래스를 정의 했다면
파생 클래스 에서는 반드시 베이스 생성자를 호출하는 방법을 알려줘야한다.
파생::파생() : 베이스(7)//여기서 인자는 데이터 멤버가 될 수 없다 왜인지 생각해보자

객체 소멸 과정
	1. 현재 클래스의 소멸자를 호출한다.
	2. 현재 클래스의 데이터 멤버를 생성할 때와 반대 순서로 삭제한다.
	3. 부모 클래스가 있다면 부모의 소멸자를 호출한다.
만약 소멸자를 virtual로 생성 안한 파생클래스 객체를 가르키는 베이스클래스 객체 포인터를 삭제한다면
문제가 생긴다. 생각해보자 -

순수 가상메서드가 하나라도 정의된 클래스를 추상 클래스라고 부른다
->추상 클래스에 대해서는 인트턴스를 만들 수 없다.

*/