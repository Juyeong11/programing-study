/*
&(레퍼런스)
레퍼런스란 일종의 변수에 대한 별칭(앨리어스)이다
레퍼런스를 이용해서 수정한 내용은 그 래퍼런스가 가리키는 변수의 값에 그대로 반영된다. -> 레퍼런스를 사용한다는 말은 수정을 하겠다?

int& unnameRef = 5; 5라는 상수를 레퍼런스를 이용해 바꾼다는건 말이 안된다 -> 컴파일 오류
const int& unnameRef = 7; 레퍼런스도 상수(const)이기 때문에 7을 바꾸지 않는다는 약속이 되있다-> 실행 가능

임시 객체를 반환하는 getString()
string& string1 = getString() 오류
const string& string1 = getString()

래퍼런스를 초기화하고 나면 래퍼런스가 가리키는 변수를 변경할 수 없고, 그 변수의 값만 바꿀 수 있다.
int x = 3, z = 5;
int &a = x;
int &v = z;
zRef = xRef //값을 예상해보자

래퍼런스는 모든 타입에 대해 만들 수 있다 -> 포인터 타입을 가리키는 레퍼런스도 만들 수 있다.
int* intP;
int*& ptrRef = intP;
ptrRef = new int;
*ptrRef = 5;

매개변수가 레퍼런스 타입인 함수나 메서드에 포인터를 전달하려면 포인터를 역참조해서 전달하면 포인터를 레퍼런스로 변환 할 수 있다.

매개변수나 리턴값을 포인터와 래퍼런스 중 어느 것으로 표현하는 것이 적합한지 판단하는 한 가지 방법은 메모리의 소유권이 어디에 있는지 따져보는 것이다.

const키워드는 항상 바로 왼쪽에 나온 대상에 적용된다

constexpr -> 함수를 상수 표현식으로 정의해준다.

소스파일마다 정의된 이름들은 외부링크나 내부링크를 통해 서로 연결된다.
static 키워드를 사용하면 내부 링크가 적용되어 다른 소스 파일에서 해당 정의를 호출할 수 없게 된다.
->namspace 를 선언하는 것과 같다.

extern키워드를 사용하면 컴파일러를 이를 정의가 아닌 선언으로 취급해 그 변수에 대한 메모리를 할당하지 않는다.
-> 이 키워드를 붙여서 전역 변수로 만들면 여러 소스 파일에서 공유 할 수 있다.

타입 엘리어스(using)는 스코프 지정자도 포함 시킬 수 있다.
타입 앨리어스를 이용해 함수 포인터를 다룰 수 있다 using MatchFuction = bool(*)(int, int);

auto는 래퍼런스와 const속성을 제거한다. auto result = std::as_const(str); //어떻게 될지 생각해보자
*/