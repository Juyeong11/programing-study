STL(standard Template Library)

- 컨테이너, 반복자, 알고리즘, 함수 객체, 어댑터, 할당기



* 컨테이너

- 객체를 저장하는 객체

 * 표준 시퀸스 컨테이너 - 컨테이너 원소가 자신만의 삽입 위치를 가진다.
 * 표준 연관 컨테이너   - 삽입순서와는 다르게 특정 정렬 기준에 의해 자동 정렬
 
 * 배열 기반 컨테이너 -  말 그대로 하나의 메모리 단위에 저장( vector, deque)
 * 노드 기반 컨테이너 -  노드에 저장
 


* 반복자 iterator

- 포인터와 비슷한 개념으로 컨테이너의 원소를 가리키고, 가리키는 원소에 접근하여 다음 원소를 가리키게 하는 기능을 한다.
 이 반복자 덕에 알고리즘은 특정 컨테이너에 종속적이지 않고 독립적이면서도 언제든지 컨테이너와 결합하여 동작할 수 있습니다.
 [begin, end)!

 * 입력 반복자      : 현 위치의 원소를 한 번만 읽을 수 있는 반복자                                 istream  
 * 출력 반복자      : 현 위치의 원소를 한 번만 쓸 수 있는 반복자                                   ostream
 * 순방향 반복자    : 입력, 출력 반복자 기능에 순방향으로 이동++이 가능한 재할당될 수 있는 반복자  
 * 양방향 반복자    : 순방향 반복자 기능에 역방향으로 이동--이 가능한 반복자                       list,set,...
 * 임의 접근 반복자 : 양방향 반복자 기능에 +,- +=, -=, [] 연산이 가능한 반복자                     vector, deque

 모든 컨테이너는 양방향 반복자 이상을 제공합니다.



* 알고리즘

- 정렬, 삭제, 검색, 연산 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
 같은 기능을 수행하는 여러가지 버전으로 오버로딩된다.

 * 원소를 수정하지 않는 알고리즘
 * 원소를 수정하는 알고리즘
 * 제거 알고리즘
 * 변경 알고리즘
 * 정렬 알고리즘
 * 정렬된 범위 알고리즘
 * 수치 알고리즘

 특정 컨테이너나 원소 타입에 종속적이지 않다.



* 함수 객체
- 함수처럼 동작하는 객체로 operator() 연산자를 오버로딩한 객체 컨테이너와 알고리즘 등에 클라이언트 정책을 반영하게 함

sort(v.begin(), v.end(), less<int>()); // 오름차순 정렬이 된다.



* 어댑터
- 구성 요소의 인터페이스를 변경해 새로운 인터페이스를 갖는 구성 요소로 변경합니다.

 * 컨테이너 어댑터
  - stack, queue, priority_queue

  ex) stack 컨테이너 어댑터
     - 일반 컨테이너를 LIFO 방식의 스택 컨테이너로 변환합니다.
       empty, size, push_back, pop_back, back인터페이스를 지원하는 컨테이너는 모두 stack으로 변환할 수 있습니다.

 * 반복자 어댑터
  - reverse_iterator, back_insert_iterator, front_insert_iterator, insert_iterator
  
  ex) reverse_iterator
     - 일반 반복자의 동작을 반대로 동작시키는 역방향 반복자로 변환합니다. ->반복자가 가리키는 원소의 실제 값은 원소의 다음 원소가 된다. 반개구간이기 때문

 * 함수 어댑터
  - binder, negator, adaptor for pointers to functions

  ex) not2
     - 조건자 함수 객체(이항)를 not(반대)로 변환합니다.(조건자는 bool타입을 반환하는 함수류)

     ex) not2(less<int>()) (10,20)



* 할당기 Allocator
- 컨테이너의 메모리 할당 정책을 캡슐화한 클래스 객체로 모든 컨테이너는 자신만의 기본 할당기를 가지고 있다.
 new()와 delete()를 operator를 이용하여 오버로딩하듯이 STL의 할당기도 사용자가 직접 정의하고 사용할 수 있다.
