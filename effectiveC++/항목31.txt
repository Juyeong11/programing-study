31: 파일사이의 컴파일 의존성을 최대로 줄이자



 클래스를 컴파일 하기 위해서는 해당 클래스의 구현 세부사항에 속하는 것들이 어떻게
정의됬는지를 모르면 컴파일 자체가 불가능하다

#include<string>
#include"date.h"
#include"address.h"

#include문은 클래스를 정의한 파일과 위의 헤더 파일들 사이에 컴파일의존성이란 것을 엮어버린다.

 위의 헤더 파일중 하나만 바뀌더라도 혹은 엮어 있는 헤더파일이 바뀌기만해도
다시 컴파일 되어야 한다.



이 문제를 해결하기 위해 전방선언을 한다면 좋은 아이디어이지만 두 가지문제가 있다.

첫 번째는 표준라이브러리를 전방선언하는 경우
namespace std{
	class string;
}
 이렇게 할경우 오류가 나게된다
사실 string은 클래스가아니라 typedef로 정의한 타입동의어 이기때문이다.
제대로 전방선언하기위해 템플릿을 끌고 들어온다면 되긴하겠지만 
표준라이브러리를 직접선언할것이 아니라면 헤더만 잘 포함시키면 된다.

만약 표준헤더를 구문분석하는 단계가 진짜 문제가 된다면, 인터페이스설계를 고치는
방법외에는 없다.

두 번째 문제는 컴파일러가 컴파일 도중 객체의 크기를 전부 알아야 한다는 것이다.

 이 문제를 해결 하려면 객체의 포인터를 활용하는 방법을 사용하면 된다.
그러기 위해서는 우선 클래스를 두 클래스로 쪼개어 한쪽은 인터페이스 다른쪽은 구현을 맡는다.

여기서 주클래스에 들어가는 데이터 멤버는 구현클래스에 대한 포인터 뿐이다.
pimpl관용구(pointer to implemention) 라고 하는 구현 패턴이다.


필요한 요소들을 전방선언한다. -> 컴파일러가 컴파일 도중 객체의 크기를 전부 알아야 한다.
->객체의 포인터를 활용한다.



 헤더 파일을 만들 때는 실용적으로 의미를 갖는 한 자체조달의 행태로 만들고 안된다면
선언부에 대한 의존성을 갖도록 만들자



정리

* 어떤 타입의 객체를 정의 할때는 그 타입의 정의가 준비되어있어야 하기 때문에
객체 참조자 및 포인터로 충분한 경우에는 객체를 직접 쓰지 말자

* 클래스를 사용하는 함수를 선언할 때는 그 클래스의 정의가 필요하지 않다(값으로 전달하거나 반환하더라도).
그러므로 최대한 클래스의 선언에 의존하도록 하자

* 선언부와 정의부에 대해 별도의 헤더 파일을 제공하자



비용,문제 

핸들 클래스 구현클래스의 경우

 핸들 클래스의 멤버 함수를 호출하면 구현부객체의 데이터까지 가기위해 포인터를 타야한다.
간접화 연산이 한단계 증가
 객체를 하나씩 저장하는데 필요한 메모리 크기에 구현부 포인터의 크기가 더해짐
구현부 포인터의 초기화가 일어나야한다.(핸들클래스의 생성자안에서)

인터페이스 클래스의 경우

 가상함수를 사용하기때문에 가상 함수 호출이 일어날 때마다 가상 테이블 점프에 따르는 비용소모

 인터페이스클래스에서 파생된 객체는 죄다 가상 테이블 포인터를 지나고 있어야함

공통된 문제

 인라인함수의 도움을 제대로 끌어내기 힘들다는 점