17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

 proccessWidget(new(shared_ptr(객체)), 함수)

 컴파일러는 함수의 호출 코드를 만들기 전에 함수의 매개변수로 넘겨지는 
인자를 평가하는 순서를 밟는다.
 - 함수 호출 - new 실행 - shared_ptr생성자 호출

 이 세가지를 실행해야 하는데 실행 순서가 컴파일러 마다 다를 수 있다.
만약 2번과 3번사이 1번을 호출하다 예외 발생시 생성한 포인터가 유실되기 때문에 
객체 생성부분을 별도의 문장으로 만들어주도록하자


18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

 - 인터페이스 사이의 일관성 잡아주기
 - 기본제공 타입과 동작 호환성 유지하기
 - 사용자의 실수방지, shared_ptr의 사용자 정의 삭제가 활용 


19: 클래스 설계는 타입 설계화 똑같이 취급하자.

 * 새로운 클래스를 정의한다는 것은 새로운 타입을 하나 정의하는것이다!!! *

 - 새로 정의한 타입의 객체 생성 및 소멸
 - 객체 초기화와 대입
 - 객체가 값에 의해 전달되는 경우 복사생성자 구현방식
 - 새로운 타입이 가질 수 있는 적법한 값에 대한 제약
 - 기존의 클래스 상속 계통망에 맞출 것인가? -> 가상함수
 - 어떤 종류의 타입 변환을 허용할 것인가 -> 명시적 암시적 변환
 - 어떤 연산자와 함수를 두어야 의미가 있을까?
 - 표준 함수들 중 어떤 것을 허용하지 않을 것인가 -> private로 선언할 것들
 - 새로운 타입의 멤버에 대한 접근 권한을 어느 쪽에 줄 것인가?
 - 선언되지 않은 인터페이스로 무엇을 둘 것인가 
 - 탬플릿으로 대체할수 있지 않을까?


20: 값에 의한 전달 보다는 상수 객체 참조자에 의한 전달 방식을 택하는 편이 대개 낫다.

 기본제공 타입, STL반복자, 함수객체 타입들은 값에 의한 전달방식이 
효율적이다

21: 함수에서 객체를 반환 해야 할 경우 참조자를 반환하려고 들지 말자.

반환되는 객체가 두 개 이상 존재할경우 더더욱 하지말자

22: 데이터 멤버가 선언될 곳은 private영역임을 명심하자

 - 문법의 일관성 - 세밀한 접근제어 - 클래스의 불변속성 - 내부 구현의 유통성
장점이 많아요